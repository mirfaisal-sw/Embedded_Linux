From b76bd9a224ce25bfc9af7bbf2e130cb96cc29f6b Mon Sep 17 00:00:00 2001
From: Mir Faisal <Mir.Faisal@harman.com>
Date: Fri, 03 Feb 2023 13:48:53 +0000
Subject: [PATCH] Driver: Integrate Boot Time KPI Marker driver.

Description: Driver source code copied from Samsung's SYS release is
	integrated and CONFIG macros are enabled for its compilation.
	To load the driver dtsi changes are done. Boot time KPI driver
	logs time stamp of various boot stages in a particular format
	in a fixed DRAM memory region and the driver poses a file
	/proc/boottime to read logged time stamp data.

Project Name : IDCEvo
Variant-Sample : BMW IDCEvo A1, B1
Change-Type : Feature
Widget-Group : Operating System
Widget-Module : ELINA Kernel
Tracking-Id : ALM-1880745
Depends-On : 00
Unit-Test : Done
DSCA-Report : NA
Domain : FsKernel

Signed-off-by: Mir Faisal <Mir.Faisal@harman.com>
Change-Id: I14a36080e4a3a776b99f64cea935ec4f0f710b14
---

diff --git a/arch/arm64/boot/dts/exynos/exynosautov920-soc-idcevo.dtsi b/arch/arm64/boot/dts/exynos/exynosautov920-soc-idcevo.dtsi
index 94240f9..e9ec0aa 100644
--- a/arch/arm64/boot/dts/exynos/exynosautov920-soc-idcevo.dtsi
+++ b/arch/arm64/boot/dts/exynos/exynosautov920-soc-idcevo.dtsi
@@ -4,6 +4,12 @@
  *
  * Copyright (c) 2022 Harman International Co., Ltd.
  */
+#include "exynosautov920-rmem.dtsi"
+
+#define DRAMBOOTLOG_MEM_ADDR            0xE5C00000
+#define DRAMBOOTLOG_MEM_SIZE            0x00100000      /* 1MB */
+#define BOOTTIME_MEM_ADDR               0xE9A41000
+#define BOOTTIME_MEM_SIZE               0x001BF000      /* 1788 KB */
 
 /* 16MB shared memory for AVB */
 &reserved_memory {
@@ -12,4 +18,22 @@
 			reg = <0x0 0xf0000000 0x01000000>;
 			status = "okay";
 		};
+
+		boottime_mem: boottime_mem {
+			compatible = "exynos,boottime_mem";
+			reg = <0x0 BOOTTIME_MEM_ADDR BOOTTIME_MEM_SIZE>;
+			status = "disabled";
+		};
 };
+
+&{/} {
+
+	boottime_log: exynos-boottime-log {
+		compatible = "samsung,exynos-boottimelog";
+		memory-region = <&boottime_mem>;
+		status = "disabled";
+	};
+
+};
+
+
diff --git a/drivers/soc/samsung/Kconfig b/drivers/soc/samsung/Kconfig
index 8c4dc6f..8960efd 100644
--- a/drivers/soc/samsung/Kconfig
+++ b/drivers/soc/samsung/Kconfig
@@ -161,6 +161,23 @@
 	help
 	  Support Exynos Firmware Secureboot
 
+config EXYNOS_BOOTTIME_LOG
+	tristate "ExynosAuto Boottime Log"
+	depends on DEBUG_FS
+	help
+	  Enables the support for ExynosAuto Boottime Log print. It initializes
+	  timestamp region in DRAM gives virtual address. Then it creates procfs
+	  file (/proc/boottime) with necessary fops to give read access from user
+	  space.
+
+config EXYNOS_KERNEL_BOOTTIME
+	bool "ExynosAuto Kernel Boottime Measurement"
+	depends on EXYNOS_BOOTTIME_LOG
+        help
+	  Supports ExynosAuto Boottime Log measurement & record by using a function
+	  "exynos_kernel_boottime_log()". To record timestamp, this function is called
+          wherever it is needed to record time stamp data.
+
 source "drivers/soc/samsung/acpm/Kconfig"
 source "drivers/soc/samsung/cal-if/Kconfig"
 source "drivers/soc/samsung/debug/Kconfig"
diff --git a/drivers/soc/samsung/Makefile b/drivers/soc/samsung/Makefile
index 026b2ff..5eea912 100644
--- a/drivers/soc/samsung/Makefile
+++ b/drivers/soc/samsung/Makefile
@@ -40,3 +40,6 @@
 # Firmware Secureboot
 obj-$(CONFIG_EXYNOS_FIRMWARE_SECUREBOOT) += exynos-fw-sb.o
 
+# Exynosauto Boottime Log
+obj-$(CONFIG_EXYNOS_BOOTTIME_LOG) += exynos-boottimelog.o
+obj-$(CONFIG_EXYNOS_KERNEL_BOOTTIME) += exynos-kernel-boottime.o
diff --git a/drivers/soc/samsung/exynos-boottimelog.c b/drivers/soc/samsung/exynos-boottimelog.c
new file mode 100644
index 0000000..8159204
--- /dev/null
+++ b/drivers/soc/samsung/exynos-boottimelog.c
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Samsung Electronics Co., Ltd.
+ *	      http://www.samsung.com/
+ *
+ * EXYNOS - Boot time table extractor
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+
+/* Time Stamp size per core */
+#define EXYNOSAUTO_TIMESTAMP_PER_CORE_SIZE (8 * 1024)
+#define IMPL_PROC_OPS
+
+struct boottimelog_data {
+	struct proc_dir_entry *proc_file;
+	void *virt_addr;
+	unsigned long phys_addr;
+	unsigned long size;
+};
+
+static struct boottimelog_data timedata = { 0 };
+
+static void *exynos_request_region(unsigned long addr, unsigned int size)
+{
+	int i;
+	unsigned int num_pages = (size >> PAGE_SHIFT);
+	pgprot_t prot = pgprot_writecombine(PAGE_KERNEL);
+	struct page **pages = NULL;
+	void *v_addr = NULL;
+
+	if (!addr)
+		return NULL;
+
+	pages = kmalloc_array(num_pages, sizeof(struct page *), GFP_ATOMIC);
+	if (!pages)
+		return NULL;
+
+	for (i = 0; i < num_pages; i++) {
+		pages[i] = phys_to_page(addr);
+		addr += PAGE_SIZE;
+	}
+
+	v_addr = vmap(pages, num_pages, VM_MAP, prot);
+	kfree(pages);
+
+	return v_addr;
+}
+
+static int boottime_show(struct seq_file *seq, void *pdata)
+{
+	seq_puts(seq, "Open Boottime\n");
+	seq_printf(seq, "Base(0x%lx) Size(0x%lx)\n", timedata.phys_addr,
+		 timedata.size);
+
+	return 0;
+}
+
+static int boottime_proc_open(struct inode *inode, struct file *file)
+{
+	struct platform_device *pdev = PDE_DATA(file_inode(file));
+	int ret;
+
+	ret = single_open(file, boottime_show, pdev);
+
+	return ret;
+}
+
+static int boottime_proc_release(struct inode *inode, struct file *file)
+{
+	int res = single_release(inode, file);
+
+	return res;
+}
+
+static ssize_t boottime_proc_read(struct file *file,
+		char *buff, size_t buff_size, loff_t *offset)
+{
+	ssize_t read_cnt = 0;
+
+	if (buff == NULL || offset == NULL)
+		return read_cnt;
+
+	if ((loff_t) timedata.size > *offset) {
+		read_cnt = min(buff_size,
+					timedata.size - (size_t) *offset);
+
+		if (copy_to_user(buff,
+				timedata.virt_addr + *offset, read_cnt))
+			read_cnt = -EFAULT;
+		else
+			*offset += read_cnt;
+	}
+
+	return read_cnt;
+}
+
+#ifdef IMPL_PROC_OPS
+static const struct proc_ops boottime_proc_fops = {
+	.proc_open      = boottime_proc_open,
+	.proc_read      = boottime_proc_read,
+	.proc_release   = boottime_proc_release,
+};
+#else
+static const struct file_operations boottime_proc_fops = {
+	.open      = boottime_proc_open,
+	.read      = boottime_proc_read,
+	.release   = boottime_proc_release,
+};
+#endif
+
+static int exynos_boottime_probe(struct platform_device *pdev)
+{
+	struct reserved_mem *rmem;
+	struct device_node *rmem_np;
+
+	dev_info(&pdev->dev, "Probe function start\n");
+
+	rmem_np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+	if (!rmem_np) {
+		dev_err(&pdev->dev, "no such memory-region\n");
+		return -ENODEV;
+	}
+
+	rmem = of_reserved_mem_lookup(rmem_np);
+	if (!rmem) {
+		dev_err(&pdev->dev, "no such reserved mem of node name %s\n",
+			pdev->dev.of_node->name);
+		return -ENODEV;
+	}
+
+	if (!rmem->base || !rmem->size)
+		return -EPROBE_DEFER;
+
+	timedata.phys_addr = rmem->base;
+	timedata.size = rmem->size;
+
+	dev_info(&pdev->dev, "Base(0x%lx) Size(0x%lx)\n", timedata.phys_addr,
+		timedata.size);
+
+	timedata.virt_addr =
+		exynos_request_region(timedata.phys_addr, timedata.size);
+
+	if (!timedata.virt_addr) {
+		dev_err(&pdev->dev, "Failed to remap boottime log area\n");
+		return -EFAULT;
+	}
+
+	timedata.proc_file = proc_create_data("boottime", 0400, NULL,
+				&boottime_proc_fops, pdev);
+
+	return 0;
+}
+
+static int exynos_boottime_remove(struct platform_device *pdev)
+{
+	if (timedata.virt_addr)
+		vunmap(timedata.virt_addr);
+
+	proc_remove(timedata.proc_file);
+
+	return 0;
+}
+
+static const struct of_device_id exynos_boottimelog_of_match_table[] = {
+	{
+		.compatible = "samsung,exynos-boottimelog",
+	},
+	{},
+};
+
+static struct platform_driver exynos_boottime_driver = {
+	.probe = exynos_boottime_probe,
+	.remove = exynos_boottime_remove,
+	.driver = {
+		.name = "exynos-boottimelog",
+		.owner = THIS_MODULE,
+		.of_match_table = exynos_boottimelog_of_match_table,
+	}
+};
+
+module_platform_driver(exynos_boottime_driver);
+
+MODULE_DESCRIPTION("ExynosAuto9 Boottime log driver");
+MODULE_AUTHOR("<jaewoo.yang@samsung.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/samsung/exynos-kernel-boottime.c b/drivers/soc/samsung/exynos-kernel-boottime.c
new file mode 100644
index 0000000..f8fd0c9
--- /dev/null
+++ b/drivers/soc/samsung/exynos-kernel-boottime.c
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Samsung Electronics Co., Ltd.
+ *	      http://www.samsung.com/
+ *
+ * EXYNOS - Exynosauto Boot time measurement support
+ */
+
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/smc.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/soc/samsung/exynos-kernel-boottime.h>
+#include <linux/soc/samsung/exynos-soc.h>
+
+#ifdef CONFIG_VLM
+#include <nk/nkern.h>
+#endif
+
+#define  MAX_CORE_CNT      10
+
+static u32 chip_id;
+static void __iomem *g_rtc_base = (void __iomem *)0xffffffff;
+
+static u32 get_kernel_running_cpu_id(void)
+{
+	u32 ret = 0;
+#ifdef CONFIG_VLM
+	static u32 cpus[MAX_CORE_CNT] = { 100, 100, 100, 100, 100, 100, 100,
+						 100, 100, 100 };
+	u32 id = raw_smp_processor_id();
+
+	if (cpus[id] >= MAX_CORE_CNT)
+		cpus[id] = hyp_call_get_cpuid();
+
+	ret = cpus[id];
+#else
+	ret = raw_smp_processor_id();
+#endif
+
+	return ret;
+}
+
+static void *exynos_boottime_request_region(unsigned long addr,
+					    unsigned int size)
+{
+	int i;
+	unsigned int num_pages = (size >> PAGE_SHIFT);
+	pgprot_t prot = pgprot_writecombine(PAGE_KERNEL);
+	struct page **pages = NULL;
+	void *v_addr = NULL;
+
+	if (!addr)
+		return NULL;
+
+	pages = kmalloc_array(num_pages, sizeof(struct page *), GFP_ATOMIC);
+	if (!pages)
+		return NULL;
+
+	for (i = 0; i < num_pages; i++) {
+		pages[i] = phys_to_page(addr);
+		addr += PAGE_SIZE;
+	}
+
+	v_addr = vmap(pages, num_pages, VM_MAP, prot);
+	kfree(pages);
+
+	return v_addr;
+}
+
+u32 get_vm_category(void)
+{
+	static u32 category = 0xffffffff;
+
+	if (category == 0xffffffff) {
+#ifdef CONFIG_VLM
+		static int vmid_for_category = -1;
+
+		if (vmid_for_category < 0)
+			vmid_for_category = (int)hyp_call_id_get();
+
+		if (vmid_for_category == 2)
+			category = EXYNOSAUTO_TIMELINE_DOM_VM2_BASE;
+		else if (vmid_for_category == 3)
+			category = EXYNOSAUTO_TIMELINE_DOM_VM3_BASE;
+		else if (vmid_for_category == 4)
+			category = EXYNOSAUTO_TIMELINE_DOM_VM4_BASE;
+		else if (vmid_for_category == 5)
+			category = EXYNOSAUTO_TIMELINE_DOM_VM5_BASE;
+		else
+			return 0x0;
+#else
+		category = EXYNOSAUTO_TIMELINE_BARE_KERNEL_BASE;
+#endif
+	}
+
+	return category;
+}
+
+void logging_core_sector(u32 index, u32 cur_rtc)
+{
+	u32 cur_cpu;
+	u32 next_offset = 0;
+	int i = 0;
+	static u32 *timebase[MAX_CORE_CNT] = { 0x0, 0x0, 0x0, 0x0, 0x0,
+						0x0, 0x0, 0x0, 0x0, 0x0 };
+
+	cur_cpu = get_kernel_running_cpu_id();
+
+	if (cur_cpu >= MAX_CORE_CNT)
+		return;
+
+	if (timebase[cur_cpu] == 0x0) {
+		for (i = 0; i < MAX_CORE_CNT; i++) {
+			timebase[i] = exynos_boottime_request_region(
+				BOOTTIME_LOG_BASE_FROM +
+					(i * BOOTTIME_LOG_PER_CORE_SIZE),
+				BOOTTIME_LOG_PER_CORE_SIZE);
+		}
+	}
+
+	next_offset = readl(timebase[cur_cpu]) + 0x10;
+
+	if (((next_offset + 0x10) < BOOTTIME_LOG_PER_CORE_SIZE) &&
+	    (cur_cpu * BOOTTIME_LOG_PER_CORE_SIZE + (next_offset + 0x10)) <
+		    BOOTTIME_LOG_SIZE) {
+		u32 category = get_vm_category();
+
+		if (category == 0x0)
+			return;
+
+		writel(next_offset, timebase[cur_cpu]);
+		next_offset = next_offset / 4;
+		writel(category, (timebase[cur_cpu] + next_offset));
+		writel(index, (timebase[cur_cpu] + next_offset) + 0x01);
+
+		writel(cur_rtc, (timebase[cur_cpu] + next_offset + 0x2));
+		writel(0x0, (timebase[cur_cpu] + next_offset + 0x3));
+	}
+}
+
+void exynos_kernel_boottime_log(u32 index)
+{
+	u32 cur_rtc = 0;
+	static void __iomem *chip_id_base = (void __iomem *)0xffffffff;
+
+	if (chip_id == 0) {
+		chip_id_base = ioremap(EXYNOS_CHIPID_BASE, 0x4);
+		if (chip_id_base == 0)
+			return;
+
+		chip_id = ioread32(chip_id_base);
+		if (chip_id < 0)
+			return;
+
+		if (chip_id == EXYNOSAUTO9_SOC_ID)
+			g_rtc_base = ioremap(EXYNOS_AUTO9_RTC_CURTICCNT_0, 0x4);
+		else
+			g_rtc_base = ioremap(EXYNOS_AUTO920_RTC_CURTICCNT_0, 0x4);
+	}
+
+	cur_rtc = ioread32(g_rtc_base);
+
+	logging_core_sector(index, cur_rtc);
+}
+EXPORT_SYMBOL_GPL(exynos_kernel_boottime_log);
diff --git a/include/linux/soc/samsung/exynos-kernel-boottime.h b/include/linux/soc/samsung/exynos-kernel-boottime.h
new file mode 100644
index 0000000..6c6d207
--- /dev/null
+++ b/include/linux/soc/samsung/exynos-kernel-boottime.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Header for EXYNOS Boot Time measurement
+ *
+ */
+
+#ifndef _EXYNOS_KERNEL_BOOT_TIME_TABLE_H
+#define _EXYNOS_KERNEL_BOOT_TIME_TABLE_H
+
+#ifdef CONFIG_EXYNOS_KERNEL_BOOTTIME
+
+#include "exynosauto9-boottimelog.h"
+
+#define BOOTTIME_LOG_PER_CORE_SIZE	(8 * 1024)
+#define EXYNOS_CHIPID_BASE              0x10000000
+#define EXYNOS_AUTO9_RTC_TIME_INFO_BASE	0x10540000
+#define EXYNOS_AUTO9_RTC_CURTICCNT_0	(EXYNOS_AUTO9_RTC_TIME_INFO_BASE + 0x90)
+#define EXYNOS_AUTO920_RTC_TIME_BASE    0x118C0000
+#define EXYNOS_AUTO920_RTC_CURTICCNT_0  (EXYNOS_AUTO920_RTC_TIME_BASE + 0x90)
+
+extern void exynos_kernel_boottime_log(u32 index);
+
+#else /* CONFIG_EXYNOS_KERNEL_BOOTTIME */
+
+#define exynos_kernel_boottime_log(a)		do { } while (0)
+
+#endif
+
+#endif /* Endo of _EXYNOS_KERNEL_BOOT_TIME_TABLE_H */
diff --git a/include/linux/soc/samsung/exynosauto9-boottimelog.h b/include/linux/soc/samsung/exynosauto9-boottimelog.h
new file mode 100644
index 0000000..3a1f253
--- /dev/null
+++ b/include/linux/soc/samsung/exynosauto9-boottimelog.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Header for EXYNOS Boot Time Table
+ *
+ */
+
+#ifndef _EXYNOS_BOOT_TIME_TABLE_H
+#define _EXYNOS_BOOT_TIME_TABLE_H
+
+/* Boot time log buffer information */
+#define BOOTTIME_LOG_BASE_FROM                  0xE9A41000
+#define BOOTTIME_LOG_BASE_TO                    0xE9C00000
+#define BOOTTIME_LOG_SIZE                       (BOOTTIME_LOG_BASE_TO - BOOTTIME_LOG_BASE_FROM)
+
+#define BOOTTIME_LOG_VM2_BASE_FROM              0xE9A63000
+#define BOOTTIME_LOG_VM3_BASE_FROM              0xE9A73000
+#define BOOTTIME_LOG_VM4_BASE_FROM              0xE9A83000
+#define BOOTTIME_LOG_VM5_BASE_FROM              0xE9A93000
+#define BOOTTIME_LOG_BARE_BASE_FROM             0xE9AA3000
+
+#define EXYNOSAUTO_TIMELINE_MAGIC               0x0badfafa
+#define EXYNOSAUTO_TIMELINE_EPBL_BASE           0x10000000
+#define EXYNOSAUTO_TIMELINE_BL2_BASE            0x20000000
+#define EXYNOSAUTO_TIMELINE_EL3MON_BASE         0x30000000
+#define EXYNOSAUTO_TIMELINE_LK_BASE             0x40000000
+#define EXYNOSAUTO_TIMELINE_BARE_KERNEL_BASE    0x50000000
+#define EXYNOSAUTO_TIMELINE_HYP_BASE            0x60000000
+#define EXYNOSAUTO_TIMELINE_DOM_SYS_BASE        0x70000000
+#define EXYNOSAUTO_TIMELINE_DOM_IVI_BASE        0x80000000
+#define EXYNOSAUTO_TIMELINE_DOM_AND_BASE        0x90000000
+#define EXYNOSAUTO_TIMELINE_QNX_BASE            0xA0000000
+#define EXYNOSAUTO_TIMELINE_SFI_BASE            0xB0000000
+#define EXYNOSAUTO_TIMELINE_DOM_VM2_BASE        0xC0000000
+#define EXYNOSAUTO_TIMELINE_DOM_VM3_BASE        0xD0000000
+#define EXYNOSAUTO_TIMELINE_DOM_VM4_BASE        0xE0000000
+#define EXYNOSAUTO_TIMELINE_DOM_VM5_BASE        0xF0000000
+
+#define SECURE_START                            0x0100
+#define SECURE_SMC                              0x0c00
+#define SECURE_EXIT                             0xffff
+
+#define KERNEL_START_KERNEL                     0xb100
+#define KERNEL_SETUP_ARCH_START                 0xb110
+#define KERNEL_SETUP_ARCH_DONE                  0xb11f
+#define KERNEL_BOOT_MEM_INIT_START              0xb111
+#define KERNEL_BOOT_MEM_INIT_DONE               0xb112
+#define KERNEL_SPARSE_INIT                      0xb113
+#define KERNEL_ZONE_INIT                        0xb114
+#define KERNEL_MMU_INIT_START                   0xb120
+#define KERNEL_FTRACE_INIT                      0xb000
+#define KERNEL_MEM_INIT                         0xb005
+#define KERNEL_CACHE_INIT                       0xb006
+#define KERNEL_PTABLE_INIT_DONE                 0xb007
+#define KERNEL_VM_ALLOC_INIT                    0xb008
+#define KERNEL_IO_REMAP_HUGE_INIT               0xb009
+#define KERNEL_ESPFIX_INIT                      0xb00a
+#define KERNEL_PTI_INIT                         0xb00b
+#define KERNEL_SCHEDULE_INIT                    0xb00c
+#define KERNEL_CONSOLE_INIT                     0xb00d
+#define KERNEL_MEM_ENC_INIT                     0xb00e
+#define KERNEL_INIT_DONE                        0xb001
+#define KERNEL_PCIE_DONE                        0xb002
+#define KERNEL_GRAPHICS_DONE                    0xb003
+#define KERNEL_ETH_DONE                         0xb004
+#define KERNEL_MEM_LEAK_INIT                    0xb200
+#define KERNEL_DGB_LATE_INIT                    0xb201
+#define KERNEL_TIME_INIT                        0xb202
+#define KERNEL_INIT_THREAD_START                0xb300
+#define KERNEL_INIT_DEFAULT_MODULE_START        0xb310
+#define KERNEL_INIT_MOUNT_ROOT_FS_DONE          0xb311
+#define KERNEL_INIT_EXECUTE_BOOT_ARGS           0xb312
+#define KERNEL_INIT_EXECUTE_BOOT_ARGS_DONE      0xb313
+#define KERNEL_INIT_ANOTHER_WORKING_START       0xb314
+#define KERNEL_INIT_DRIVERS_START               0xb315
+#define KERNEL_INIT_CALL_DRIVERS_DONE           0xb316
+#define KERNEL_INIT_UFS_START                   0xb317
+#define KERNEL_INIT_UFS_DONE                    0xb318
+#define KERNEL_PLATFORM_POPULATE_INIT           0xb319
+#define KERNEL_PLATFORM_POPULATE_DONE           0xb31a
+#define KERNEL_INIT_INTERNAL_DRIVERS_START      0xb31b
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_0          0xb31c
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_1          0xb31d
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_2          0xb31e
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_3          0xb31f
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_4          0xb320
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_5          0xb321
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_6          0xb322
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_7          0xb323
+#define KERNEL_LEVEL_INIT_DEBUG_CALL_8          0xb324
+
+#define KERNEL_ACPM_MFD_BUS_INIT                0xb500
+#define KERNEL_ACPM_MFD_BUS_DONE                0xb501
+
+#define KERNEL_TRACE_FS_INIT                    0xb700
+#define KERNEL_TRACE_FS_DONE                    0xb701
+
+#define KERNEL_SECONDARY_KERNEL_START           0xc000
+#define KERNEL_SECONDARY_PRE_SMP_INITCALL       0xc100
+#define KERNEL_SECONDARY_SMP_INIT               0xc200
+#define KERNEL_CPU_CORE_IDLE                    0xcfff
+
+#define DISPLAY_BASE                            (0xD000)
+#define KERNEL_DPU_DRV_DONE                     (DISPLAY_BASE + 0x1)
+#define KERNEL_DPU_DSI0_HPD                     (DISPLAY_BASE + 0x2)
+#define KERNEL_DPU_DSI1_HPD                     (DISPLAY_BASE + 0x3)
+#define KERNEL_DPU_DP0__HPD                     (DISPLAY_BASE + 0x4)
+#define KERNEL_DPU_DP1__HPD                     (DISPLAY_BASE + 0x5)
+
+#define KERNEL_DPU_DP0_SST1                     (KERNEL_DPU_DP1__HPD + 0x1)
+#define KERNEL_DPU_DP0_SST2                     (KERNEL_DPU_DP0_SST1 + 0x1)
+#define KERNEL_DPU_DP0_SST3                     (KERNEL_DPU_DP0_SST1 + 0x2)
+#define KERNEL_DPU_DP0_SST4                     (KERNEL_DPU_DP0_SST1 + 0x3)
+#define KERNEL_DPU_DP1_SST1                     (KERNEL_DPU_DP0_SST1 + 0x4)
+#define KERNEL_DPU_DP1_SST2                     (KERNEL_DPU_DP0_SST1 + 0x5)
+#define KERNEL_DPU_DP1_SST3                     (KERNEL_DPU_DP0_SST1 + 0x6)
+#define KERNEL_DPU_DP1_SST4                     (KERNEL_DPU_DP0_SST1 + 0x7)
+#define KERNEL_DPU_DSI0_READY                   (KERNEL_DPU_DP0_SST1 + 0x8)
+#define KERNEL_DPU_DSI1_READY                   (KERNEL_DPU_DP0_SST1 + 0x9)
+
+#define KERNEL_DPU_DEC0_FRAME                   (KERNEL_DPU_DSI1_READY + 0x1)
+#define KERNEL_DPU_DEC1_FRAME                   (KERNEL_DPU_DEC0_FRAME + 0x1)
+#define KERNEL_DPU_DEC2_FRAME                   (KERNEL_DPU_DEC0_FRAME + 0x2)
+#define KERNEL_DPU_DEC3_FRAME                   (KERNEL_DPU_DEC0_FRAME + 0x3)
+#define KERNEL_DPU_DEC4_FRAME                   (KERNEL_DPU_DEC0_FRAME + 0x4)
+#define KERNEL_DPU_DEC5_FRAME                   (KERNEL_DPU_DEC0_FRAME + 0x5)
+
+#endif /* _EXYNOS_BOOT_TIME_TABLE_H */
diff --git a/init/main.c b/init/main.c
index 06b9835..8ea446b 100644
--- a/init/main.c
+++ b/init/main.c
@@ -108,6 +108,10 @@
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
 
+#if IS_ENABLED(CONFIG_EXYNOS_KERNEL_BOOTTIME)
+#include <linux/soc/samsung/exynos-kernel-boottime.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/initcall.h>
 
@@ -1530,6 +1534,10 @@
 
 	rcu_end_inkernel_boot();
 
+#if IS_ENABLED(CONFIG_EXYNOS_KERNEL_BOOTTIME)
+	exynos_kernel_boottime_log(KERNEL_INIT_DONE);
+#endif
+
 	do_sysctl_args();
 
 	if (ramdisk_execute_command) {
