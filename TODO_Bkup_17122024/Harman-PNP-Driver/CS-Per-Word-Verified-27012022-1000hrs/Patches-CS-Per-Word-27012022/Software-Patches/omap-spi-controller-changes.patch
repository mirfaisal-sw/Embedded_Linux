diff --git a/drivers/spi/spi-omap2-mcspi.c b/drivers/spi/spi-omap2-mcspi.c
index 810c297..9af19d4 100644
--- a/drivers/spi/spi-omap2-mcspi.c
+++ b/drivers/spi/spi-omap2-mcspi.c
@@ -113,8 +113,7 @@ struct omap2_mcspi_dma {
 /* use PIO for small transfers, avoiding DMA setup/teardown overhead and
  * cache operations; better heuristics consider wordsize and bitrate.
  */
-#define DMA_MIN_BYTES			160
-
+#define DMA_MIN_BYTES			4096 //160 /*MIR changed 160 to 4096*/
 
 /*
  * Used for context save and restore, structure members to be updated whenever
@@ -246,6 +245,14 @@ static void omap2_mcspi_set_cs(struct spi_device *spi, bool enable)
 	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
 	u32 l;
 
+	/*MIR*/
+	static u32 cnt = 0;
+	if(enable)
+	{
+		cnt++;
+		pr_info("MIR : CS toggled - %d times",cnt);
+	}
+
 	/* The controller handles the inverted chip selects
 	 * using the OMAP2_MCSPI_CHCONF_EPOL bit so revert
 	 * the inversion from the core spi_set_cs function.
@@ -666,11 +673,17 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 	void __iomem		*chstat_reg;
 	int			word_len;
 
+	/*MIR*/
+	u8 tmp = 0;
+
 	mcspi = spi_master_get_devdata(spi->master);
 	count = xfer->len;
 	c = count;
 	word_len = cs->word_len;
 
+	/*MIR*/
+	pr_info("MIR word count - %d\n",c);
+	pr_info("MIR word len = %d bits\n",word_len);
 	l = mcspi_cached_chconf0(spi);
 
 	/* We store the pre-calculated register addresses on stack to speed
@@ -691,6 +704,12 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 
 		do {
 			c -= 1;
+			
+			/*MIR*/
+			tmp++;
+			pr_info("MIR do while iteration cnt - %d\n",tmp);
+			omap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH); /*Activate CS*/
+
 			if (tx != NULL) {
 				if (mcspi_wait_for_reg_bit(chstat_reg,
 						OMAP2_MCSPI_CHSTAT_TXS) < 0) {
@@ -729,6 +748,10 @@ omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
 				dev_vdbg(&spi->dev, "read-%d %02x\n",
 						word_len, *(rx - 1));
 			}
+
+		/*MIR*/
+		omap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH)); /*Deactivate CS*/
+
 		} while (c);
 	} else if (word_len <= 16) {
 		u16		*rx;
@@ -1110,9 +1133,11 @@ static int omap2_mcspi_work_one(struct omap2_mcspi *mcspi,
 		par_override = 1;
 
 	omap2_mcspi_set_enable(spi, 0);
-
+	
+	#if 0 /*MIR*/
 	if (gpio_is_valid(spi->cs_gpio))
 		omap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH);
+	#endif
 
 	if (par_override ||
 	    (t->speed_hz != spi->max_speed_hz) ||
@@ -1198,8 +1223,10 @@ out:
 
 	omap2_mcspi_set_enable(spi, 0);
 
+	#if 0 /*MIR*/
 	if (gpio_is_valid(spi->cs_gpio))
 		omap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH));
+	#endif
 
 	if (mcspi->fifo_depth > 0 && t)
 		omap2_mcspi_set_fifo(spi, t, 0);
