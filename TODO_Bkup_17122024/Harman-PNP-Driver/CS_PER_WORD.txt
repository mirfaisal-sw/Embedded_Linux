
1)
==========================
spi-omap2-mcspi.c
==========================

static int omap2_mcspi_work_one(struct omap2_mcspi *mcspi,
                struct spi_device *spi, struct spi_transfer *t)
{

        /* We only enable one channel at a time -- the one whose message is
         * -- although this controller would gladly
         * arbitrate among multiple channels.  This corresponds to "single
         * channel" master mode.  As a side effect, we need to manage the
         * chipselect with the FORCE bit ... CS != channel enable.
         */

        struct spi_master               *master;
        struct omap2_mcspi_dma          *mcspi_dma;
        struct omap2_mcspi_cs           *cs;
        struct omap2_mcspi_device_config *cd;
        int                             par_override = 0;
        int                             status = 0;
        u32                             chconf;

        master = spi->master;
        mcspi_dma = mcspi->dma_channels + spi->chip_select;
        cs = spi->controller_state;
        cd = spi->controller_data;

        /*MIR*/
        dump_stack();

        /*
         * The slave driver could have changed spi->mode in which case
         * it will be different from cs->mode (the current hardware setup).
         * If so, set par_override (even though its not a parity issue) so
		 * omap2_mcspi_setup_transfer will be called to configure the hardware
         * with the correct mode on the first iteration of the loop below.
         */
        if (spi->mode != cs->mode)
                par_override = 1;

        omap2_mcspi_set_enable(spi, 0);

        #if 0 /*MIR*/
        if (gpio_is_valid(spi->cs_gpio))
                omap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH);
        #endif

        if (par_override ||
            (t->speed_hz != spi->max_speed_hz) ||
            (t->bits_per_word != spi->bits_per_word)) {
                par_override = 1;
                status = omap2_mcspi_setup_transfer(spi, t);
                if (status < 0)
                        goto out;
                if (t->speed_hz == spi->max_speed_hz &&
                    t->bits_per_word == spi->bits_per_word)
                        par_override = 0;
        }
        if (cd && cd->cs_per_word) {
                chconf = mcspi->ctx.modulctrl;
                chconf &= ~OMAP2_MCSPI_MODULCTRL_SINGLE;
                mcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, chconf);
                mcspi->ctx.modulctrl =
                        mcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);
        }

        chconf = mcspi_cached_chconf0(spi);
        chconf &= ~OMAP2_MCSPI_CHCONF_TRM_MASK;
        chconf &= ~OMAP2_MCSPI_CHCONF_TURBO;
		
		if (t->tx_buf == NULL)
                chconf |= OMAP2_MCSPI_CHCONF_TRM_RX_ONLY;
        else if (t->rx_buf == NULL)
                chconf |= OMAP2_MCSPI_CHCONF_TRM_TX_ONLY;

        if (cd && cd->turbo_mode && t->tx_buf == NULL) {
                /* Turbo mode is for more than one word */
                if (t->len > ((cs->word_len + 7) >> 3))
                        chconf |= OMAP2_MCSPI_CHCONF_TURBO;
        }

        mcspi_write_chconf0(spi, chconf);

        if (t->len) {
                unsigned        count;

                if ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&
                    (t->len >= DMA_MIN_BYTES))
                        omap2_mcspi_set_fifo(spi, t, 1);

                omap2_mcspi_set_enable(spi, 1);

                /* RX_ONLY mode needs dummy data in TX reg */
                if (t->tx_buf == NULL)
                        writel_relaxed(0, cs->base
                                        + OMAP2_MCSPI_TX0);

                if ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&
                    (t->len >= DMA_MIN_BYTES))
                        count = omap2_mcspi_txrx_dma(spi, t);
                else
                        count = omap2_mcspi_txrx_pio(spi, t);

                if (count != t->len) {
                        status = -EIO;
                        goto out;
				              }
        }

        omap2_mcspi_set_enable(spi, 0);

        if (mcspi->fifo_depth > 0)
                omap2_mcspi_set_fifo(spi, t, 0);

out:
        /* Restore defaults if they were overriden */
        if (par_override) {
                par_override = 0;
                status = omap2_mcspi_setup_transfer(spi, NULL);
        }

        if (cd && cd->cs_per_word) {
                chconf = mcspi->ctx.modulctrl;
                chconf |= OMAP2_MCSPI_MODULCTRL_SINGLE;
                mcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, chconf);
                mcspi->ctx.modulctrl =
                        mcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);
        }

        omap2_mcspi_set_enable(spi, 0);

        #if 0
        if (gpio_is_valid(spi->cs_gpio))
                omap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH));
        #endif

        if (mcspi->fifo_depth > 0 && t)
                omap2_mcspi_set_fifo(spi, t, 0);

        return status;
}

2)
=*********************************************=
 struct omap2_mcspi_device_config {
        unsigned turbo_mode:1;

        /* toggle chip select after every word */
        unsigned cs_per_word:1;
 };
 
 struct omap2_mcspi_device_config *cd;
 .
 .
 . 
 cd = spi->controller_data;
 .
 .
 .
 if (cd && cd->cs_per_word) {
                chconf = mcspi->ctx.modulctrl;
                chconf |= OMAP2_MCSPI_MODULCTRL_SINGLE;
                mcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, chconf);
                mcspi->ctx.modulctrl =
                        mcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);
 }
=*********************************************=

3)=============================================
  struct spi_device
  =============================================
  /**
 * struct spi_device - Master side proxy for an SPI slave device
 * @dev: Driver model representation of the device.
 * @master: SPI controller used with the device.
 * @max_speed_hz: Maximum clock rate to be used with this chip
 *      (on this board); may be changed by the device's driver.
 *      The spi_transfer.speed_hz can override this for each transfer.
 * @chip_select: Chipselect, distinguishing chips handled by @master.
 * @mode: The spi mode defines how data is clocked out and in.
 *      This may be changed by the device's driver.
 *      The "active low" default for chipselect mode can be overridden
 *      (by specifying SPI_CS_HIGH) as can the "MSB first" default for
 *      each word in a transfer (by specifying SPI_LSB_FIRST).
 * @bits_per_word: Data transfers involve one or more words; word sizes
 *      like eight or 12 bits are common.  In-memory wordsizes are
 *      powers of two bytes (e.g. 20 bit samples use 32 bits).
 *      This may be changed by the device's driver, or left at the
 *      default (0) indicating protocol words are eight bit bytes.
 *      The spi_transfer.bits_per_word can override this for each transfer.
 * @irq: Negative, or the number passed to request_irq() to receive
 *      interrupts from this device.
 * @controller_state: Controller's runtime state
 * @controller_data: Board-specific definitions for controller, such as
 *      FIFO initialization parameters; from board_info.controller_data
 * @modalias: Name of the driver to use with this device, or an alias
 *      for that name.  This appears in the sysfs "modalias" attribute
 *      for driver coldplugging, and in uevents used for hotplugging
 * @cs_gpio: gpio number of the chipselect line (optional, -ENOENT when
 *      when not using a GPIO line)
 *
 *
 * @statistics: statistics for the spi_device
 *
 * A @spi_device is used to interchange data between an SPI slave
 * (usually a discrete chip) and CPU memory.
 *
 * In @dev, the platform_data is used to hold information about this
 * device that's meaningful to the device's protocol driver, but not
 * to its controller.  One example might be an identifier for a chip
 * variant with slightly different functionality; another might be
 * information about how this particular board wires the chip's pins.
 */
struct spi_device {
        struct device           dev;
        struct spi_master       *master;
        u32                     max_speed_hz;
        u8                      chip_select;
        u8                      bits_per_word;
        u16                     mode;
#define SPI_CPHA        0x01                    /* clock phase */
#define SPI_CPOL        0x02                    /* clock polarity */
#define SPI_MODE_0      (0|0)                   /* (original MicroWire) */
#define SPI_MODE_1      (0|SPI_CPHA)
#define SPI_MODE_2      (SPI_CPOL|0)
#define SPI_MODE_3      (SPI_CPOL|SPI_CPHA)
#define SPI_CS_HIGH     0x04                    /* chipselect active high? */
#define SPI_LSB_FIRST   0x08                    /* per-word bits-on-wire */
#define SPI_3WIRE       0x10                    /* SI/SO signals shared */
#define SPI_LOOP        0x20                    /* loopback mode */
#define SPI_NO_CS       0x40                    /* 1 dev/bus, no chipselect */
#define SPI_READY       0x80                    /* slave pulls low to pause */
#define SPI_TX_DUAL     0x100                   /* transmit with 2 wires */
#define SPI_TX_QUAD     0x200                   /* transmit with 4 wires */
#define SPI_RX_DUAL     0x400                   /* receive with 2 wires */
#define SPI_RX_QUAD     0x800                   /* receive with 4 wires */
        int                     irq;
        void                    *controller_state;
        void                    *controller_data;
        char                    modalias[SPI_NAME_SIZE];
        int                     cs_gpio;        /* chip select gpio */

        /* the statistics */
        struct spi_statistics   statistics;

        /*
         * likely need more hooks for more protocol options affecting how
         * the controller talks to each chip, like:
         *  - memory packing (12 bit samples into low bits, others zeroed)
         *  - priority
         *  - drop chipselect after each word
         *  - chipselect delays
         *  - ...
         */
};


4)======================================================+
		spi_board_info
========================================================+
/**
 * struct spi_board_info - board-specific template for a SPI device
 * @modalias: Initializes spi_device.modalias; identifies the driver.
 * @platform_data: Initializes spi_device.platform_data; the particular
 *      data stored there is driver-specific.
 * @controller_data: Initializes spi_device.controller_data; some
 *      controllers need hints about hardware setup, e.g. for DMA.
 * @irq: Initializes spi_device.irq; depends on how the board is wired.
 * @max_speed_hz: Initializes spi_device.max_speed_hz; based on limits
 *      from the chip datasheet and board-specific signal quality issues.
 * @bus_num: Identifies which spi_master parents the spi_device; unused
 *      by spi_new_device(), and otherwise depends on board wiring.
 * @chip_select: Initializes spi_device.chip_select; depends on how
 *      the board is wired.
 * @mode: Initializes spi_device.mode; based on the chip datasheet, board
 *      wiring (some devices support both 3WIRE and standard modes), and
 *      possibly presence of an inverter in the chipselect path.
 *
 * When adding new SPI devices to the device tree, these structures serve
 * as a partial device template.  They hold information which can't always
 * be determined by drivers.  Information that probe() can establish (such
 * as the default transfer wordsize) is not included here.
 *
 * These structures are used in two places.  Their primary role is to
 * be stored in tables of board-specific device descriptors, which are
 * declared early in board initialization and then used (much later) to
 * populate a controller's device tree after the that controller's driver
 * initializes.  A secondary (and atypical) role is as a parameter to
 * spi_new_device() call, which happens after those controller drivers
 * are active in some dynamic board configuration models.
 */
struct spi_board_info {
        /* the device name and module name are coupled, like platform_bus;
         * "modalias" is normally the driver name.
         *
         * platform_data goes to spi_device.dev.platform_data,
         * controller_data goes to spi_device.controller_data,
         * irq is copied too
         */
        char            modalias[SPI_NAME_SIZE];
        const void      *platform_data;
        void            *controller_data;
        int             irq;

        /* slower signaling on noisy or low voltage boards */
        u32             max_speed_hz;


        /* bus_num is board specific and matches the bus_num of some
         * spi_master that will probably be registered later.
         *
         * chip_select reflects how this chip is wired to that master;
         * it's less than num_chipselect.
         */
        u16             bus_num;
        u16             chip_select;

        /* mode becomes spi_device.mode, and is essential for chips
         * where the default of SPI_CS_HIGH = 0 is wrong.
         */
        u16             mode;

        /* ... may need additional spi_device chip config data here.
         * avoid stuff protocol drivers can set; but include stuff
         * needed to behave without being bound to a driver:
         *  - quirks like clock rate mattering when not selected
         */
};

5) ============================================================
   Sample setting of device from board_info be
   ============================================================
   #include <stdio.h>
#include <stdint.h>

struct omap2_mcspi_device_config {
        unsigned turbo_mode:1;

        /* toggle chip select after every word */
        unsigned cs_per_word:1;
 };

int main()
{
        struct omap2_mcspi_device_config config,*config_device;

        int size = sizeof(config);
        config.turbo_mode = 0;
        config.cs_per_word = 1;

        void *controller_data = &config;

        config_device = controller_data;

        printf("Size of struct be - %d\n", size);
        printf("User's devic config  data be, turbo_mode - %x, cs_per_word - %x\n",config.turbo_mode, config.cs_per_word);
        printf("Spi controller has data, turbo_mode  = %d, cs_per_word = %d\n", config_device->turbo_mode,config_device->cs_per_word);

        return 0;

}

4) Other App- 

#include <stdio.h>
#include <stdint.h>

struct omap2_mcspi_device_config {
        unsigned turbo_mode:1;

        /* toggle chip select after every word */
        unsigned cs_per_word:1;
};

struct spi_board_info{

        void *data;
};



int main()
{
        struct omap2_mcspi_device_config config,*config_device;

        int size = sizeof(config);
        config.turbo_mode = 0;
        config.cs_per_word = 1;

        void *controller_data = &config;

        /* Dynamic SPI node for PNP */
        struct spi_board_info spi_device_info_pnp = {

        /*MIR*/
        .data = &config,
        };

        config_device = spi_device_info_pnp.data;//controller_data;

        printf("Size of struct be - %d\n", size);
        printf("User's devic config  data be, turbo_mode - %x, cs_per_word - %x\n",config.turbo_mode, config.cs_per_word);

        printf("Spi controller has data, turbo_mode  = %d, cs_per_word = %d\n", config_device->turbo_mode,config_device->cs_per_word);
                                
        return 0;

}


